import React from 'react';
import propTypes from 'prop-types';
import bacon from 'baconjs';

import {IsomorphicContext, HYDRATION, SERVER} from './context';
import {noImmediateStateOnHydrationError, noImmediateStateOnRenderError, noImmediateStateOnServerError} from './errors';

class Connector extends React.Component {
    static propTypes = {
        createElement: propTypes.func.isRequired,
        data$: propTypes.instanceOf(bacon.Observable).isRequired,
        isEqual: propTypes.func,
        name: propTypes.string.isRequired,
        elementId: propTypes.string,
    };

    static contextType = IsomorphicContext;

    static getDerivedStateFromProps(props, state) {
        // Switch data$ streams.
        state.bus.push(props.data$);

        // Track the current stream
        return {data$: props.data$};
    }

    constructor(props, context) {
        super(props, context);

        this.state = {
            bus: new bacon.Bus(),
        };

        if (this.context === SERVER) {
            // Subscribe and unsubscribe to get an immediate value from the stream.
            // If we're *really* server-side, data$ is generated by bacon.constant from the initial value produced by
            // getData when it eventually resolves, so this should *always* produce initial state.
            // Nevertheless, it's possible not to have an initial state when we're using the server build in the
            // browser.
            props.data$
                .onValue((value) => {
                    this.state.value = value; // eslint-disable-line react/no-direct-mutation-state
                })();

            if (process.env.NODE_ENV === 'development' && !this.state.value) {
                console.error(noImmediateStateOnServerError(name));
            }
        } else {
            // When the isomorphic component receives new props, it creates a new data$ stream.
            // When this happens, switch streams using flatMapLatest.
            const data$ = this.state.bus
                .startWith(props.data$)
                .skipDuplicates()
                .flatMapLatest((stream$) => stream$)
                .toProperty();

            // Use the immediately produced stream event to set initial state.
            this.observer = (value) => {
                this.state.value = value;
            };

            this.unsubscribe = (
                props.isEqual
                    ? data$.skipDuplicates(props.isEqual)
                    : data$
            )
                .onValue((value) => {
                    this.observer(value);
                });

            // If the stream didn't immediately produce an event, we have no initial state, so we can't hydrate.
            // Client-side, getData should produce an event immediately and, when hydrating, use the hydration object to
            // generate its value.
            if (!this.state.value) {
                this.unsubscribe();
                this.unsubscribe = undefined;

                if (process.env.NODE_ENV === 'development') {
                    if (context === HYDRATION) { // eslint-disable-line max-depth
                        console.warn(noImmediateStateOnHydrationError(props.name, props.elementId));
                    } else {
                        console.warn(noImmediateStateOnRenderError(props.name));
                    }
                }
            }
        }
    }

    componentDidMount() {
        this.observer = (value) => {
            this.setState({value});
        };
    }

    componentWillUnmount() {
        if (this.unsubscribe) {
            this.unsubscribe();
        }
    }

    render() {
        return this.state.value
            ? this.props.createElement(this.state.value)
            : null;
    }
}

export default function Connect({
    context: Context,
    isEqual,
    children,
}) {
    return (
        <Context.Consumer>
            {({data$, name, elementId}) => (
                <Connector
                    createElement={children}
                    {...{data$, isEqual, name, elementId}}
                />
            )}
        </Context.Consumer>
    );
}

Connect.propTypes = {

    /** React context for all instances of this component */
    context: propTypes.object.isRequired,

    /** If provided: Given two consecutive states, a and b, skip state b if isEqual(a, b). */
    isEqual: propTypes.func,

    /** A function that converts isomorphic component state into React elements */
    children: propTypes.func.isRequired,
};
