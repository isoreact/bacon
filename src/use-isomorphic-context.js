import {useContext, useEffect, useRef, useState} from 'react';

import {IsomorphicContext, HYDRATION, SERVER} from './context';
import {noContext, noImmediateStateOnHydrationError, noImmediateStateOnRenderError, noImmediateStateOnServerError} from './errors';

export default function useIsomorphicContext(context, isEqual) {
    const phase = useContext(IsomorphicContext)();

    if (phase === SERVER) {
        const {data$, name} = useContext(context);
        const [state] = useState(() => {
            let immediateState = null;

            // Subscribe and unsubscribe to get an immediate value from the stream.
            // If we're *really* server-side, data$ is generated by bacon.constant from the initial value produced by
            // getData when it eventually resolves, so this should *always* produce initial state.
            // Nevertheless, it's possible not to have an initial state according to the explanation in the error
            // message a few lines down.
            data$.onValue((value) => {
                immediateState = value;
            })();

            if (process.env.NODE_ENV === 'development' && !immediateState) {
                console.error(noImmediateStateOnServerError(name));
            }

            return immediateState;
        });

        return state;
    } else {
        const {data$, name, elementId} = (useContext(context) || {});
        const subscription = useRef(null);

        let immediateState = null;

        // On the first event (which should be immediate), set the immediate value.
        const observer = useRef((value) => {
            immediateState = value;
        });

        const [state, setState] = useState(() => {
            // If we're not in the context's scope, log an error and move on.
            if (!data$) {
                console.error(noContext());

                // Default to {} so errors aren't thrown when destructuring the result of useIsomorphicContext(context)
                return {};
            }

            subscription.current = (
                isEqual
                    ? data$.skipDuplicates(isEqual)
                    : data$
            )
                .onValue((value) => {
                    observer.current(value);
                });

            if (!immediateState) {
                if (process.env.NODE_ENV === 'development') {
                    if (phase === HYDRATION) {
                        // This is more severe on hydration than pure client-side rendering, because it will cause a hydration mismatch. The
                        // hydration object provided to getData should have sufficient data to product the first event immediately.
                        console.error(noImmediateStateOnHydrationError(name, elementId));
                    } else {
                        // This is less sever on pure client-side rendering than when hydrating. Nevertheless, it's a bad idea to render a
                        // component without props - even as an implicit loading state - when it expects props.
                        console.warn(noImmediateStateOnRenderError(name));
                    }
                }
            }

            // On subsequent events (or the initial event if it wasn't produced immediately), update the state.
            observer.current = (value) => {
                setState(value);
            };

            // In case there is no immediate state, default to {} so errors aren't thrown when destructuring the result of useIsomorphicContext(context)
            return immediateState || {};
        });

        // Unsubscribe
        useEffect(() => () => {
            if (subscription.current) {
                subscription.current();
            }
        }, []);

        return state;
    }
}
